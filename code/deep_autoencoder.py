# -*- coding: utf-8 -*-
"""deep_autoencoder_with_decoder.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yxnzledfpL5MwE6VvA9kes1zAmbJeMSr

**Deep Autoencoder**

Use to encoder and autoencoder images with different sizes.

Sequence

Create the directories:

1. `./data_png`: Load images saved on the `./images` directorie in here
2. `./data_npy `: The `.npy` are saved in here
3. `./results_png `: The results after processing images are saved in here
4. `./metrics_png`: The metricts about lost are saved in here
5. `./models_h5`: The models `.h5` are saved in here
6. `./models_yml`: The models `.yml` are saved in here, if the models are created
7. `./shapes_sizes_json`: The shaped `.json` are saved in here, if the shaped are created
8. `./histograms`: The histograms are saved in here

Install libs
"""

pip install PyYAML numpy matplotlib tensorflow

"""Import libs"""

# Numpy Matplot and Cv2 libs
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from google.colab.patches import cv2_imshow
import cv2

# OS lib
import os
import time

# Tensorflow and Keras
from tensorflow.keras.layers import Dense, Input
from tensorflow.keras.models import Model, load_model
from tensorflow.keras import backend
from tensorflow.keras.utils import plot_model

"""Directories"""

data_png = './data_png'
data_npy = './data_npy/'
results_png = './results_png/'
metrics_png = './metrics_png/'
models_h5 = './models_h5/'
models_yml = './models_yml/'
shapes_sizes_json = './shapes_sizes_json/'
histograms = './histograms/'


try:
    os.mkdir(data_png)
    os.mkdir(data_npy)
    os.mkdir(results_png)
    os.mkdir(metrics_png)
    os.mkdir(models_h5)
    os.mkdir(models_yml)
    os.mkdir(shapes_sizes_json)
    os.mkdir(histograms)
except OSError:
    print ("Creation of the directory %s failed" % data_png)
    print ("Creation of the directory %s failed" % data_npy)
    print ("Creation of the directory %s failed" % results_png)
    print ("Creation of the directory %s failed" % metrics_png)
    print ("Creation of the directory %s failed" % models_h5)
    print ("Creation of the directory %s failed" % models_yml)
    print ("Creation of the directory %s failed" % shapes_sizes_json)
    print ("Creation of the directory %s failed" % histograms)

else:
    print ("Successfully created the directory %s " % data_png)   
    print ("Successfully created the directory %s " % data_npy)   
    print ("Successfully created the directory %s " % results_png)   
    print ("Successfully created the directory %s " % metrics_png)   
    print ("Successfully created the directory %s " % models_h5)   
    print ("Successfully created the directory %s " % models_yml)   
    print ("Successfully created the directory %s " % shapes_sizes_json)
    print ("Successfully created the directory %s " % histograms)

"""Utils"""

def plot_metrics_history_subplot(history, name):
    fig, (ax1, ax2) = plt.subplots(1, 2)

    loss = history.history['loss']
    val_loss = history.history['val_loss']

    # Plot training & validation RMSE values
    ax1.plot(rmse)
    ax1.plot(val_rmse)
    ax1.set_title('RMSE')
    ax1.legend(['Train', 'Test'], loc='upper right')

    # Plot training & validation loss values
    ax2.plot(loss)
    ax2.plot(val_loss)
    ax2.set_title('Model loss')
    ax2.legend(['Train', 'Test'], loc='upper right')

    fig.savefig(metrics_png + 'history_subplot_' + name)
    
def plot_metrics_history(history, name):
    fig = plt.figure()
    plt.plot(history.history['loss'])
    plt.plot(history.history['val_loss'])
    plt.title('RMSE')
    plt.ylabel('Loss')
    plt.xlabel('Epoch')
    plt.legend(['Train', 'Test'], loc='upper right')
    plt.show()
    fig.savefig(metrics_png + 'history_loss_' + name)

def plot_all(images):
    fig = plt.figure(figsize=(32, 32))
    number_rows = int(len(images)/3) + 1
    for index in range(len(images)):
        a = fig.add_subplot(number_rows, 3, index+1)
        plt.imshow(images[index])
        plt.title(f'{index}:{images[index].shape}')
        a.axis('off')
    plt.show()
    fig.savefig(results_png + 'compare_all_images.png')

def save_image(name, image):        
    mpimg.imsave(results_png + name, image)

def save_npy(name, image): 
    name = name[:-4]
    np.save(data_npy + name + '.npy', image)

def simple_histogram(name, image):
    fig = plt.figure()
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    plt.title('Histograma Cinza')
    plt.ylabel('Pixels')
    plt.xlabel('Bins')   
    plt.hist(gray.ravel(),256,[0,256])
    fig.savefig(histograms + 'simple_histogram_' + name)
    plt.show()

def color_histogram(name, image):
    fig = plt.figure()
    color = ('b','g','r')
    plt.title('Histograma Colorido')
    plt.ylabel('Pixels')
    plt.xlabel('Bins')    
    for i,col in enumerate(color):
        histr = cv2.calcHist([image],[i],None,[256],[0,256])
        plt.plot(histr,color = col)
        plt.xlim([0,256])
    fig.savefig(histograms + 'color_histogram_' + name)
    plt.show()

"""Class TimeHistory"""

class TimingCallback(Callback):
  def __init__(self):
    self.times = []
  def on_time_begin(self, epoch, logs={}):
    self.start_time = time.time()
  def on_time_end(self, epoch, logs={}):
    self.times.append(time.time() - self.start_time)

time_callback = TimingCallback()

"""Class DeepAutoencoder"""

def rmse(y_true, y_pred):
	return backend.sqrt(backend.mean(backend.square(y_pred - y_true), axis=-1))

class DeepAutoencoder(object):
    def __init__(self, input_dim, encoded_dim):     

        # Dimensions of output and input layers
        input_layer = Input(shape=(input_dim,))
        hidden_input = Input(shape=(encoded_dim,))
        
        # Hidden layers to encoder (512, 384, 256, 128)
        encoded = Dense(8 * encoded_dim, activation='relu')(input_layer)
        encoded = Dense(6 * encoded_dim, activation='relu')(encoded)
        encoded = Dense(4 * encoded_dim, activation='relu')(encoded)
        encoded = Dense(2 * encoded_dim, activation='relu')(encoded)

        # Hidden layer (64)
        hidden_layer = Dense(encoded_dim, activation='relu')(encoded)

        # Hidden layers to decoder (128, 256, 384, 512)
        decoded = Dense(2 * encoded_dim, activation='relu')(hidden_layer)
        decoded = Dense(4 * encoded_dim, activation='relu')(decoded)
        decoded = Dense(6 * encoded_dim, activation='relu')(decoded)
        decoded = Dense(8 * encoded_dim, activation='relu')(decoded)

        # Output layer
        output_layer = Dense(input_dim, activation='sigmoid')(decoded)
        
        # Autoencoder and encoder models
        self.autoencoder = Model(input_layer, output_layer)
        self.encoder = Model(input_layer, hidden_layer)
        
        # Sequential hidden layers of encoder
        layer1 = self.autoencoder.layers[-5]
        layer2 = self.autoencoder.layers[-4]
        layer3 = self.autoencoder.layers[-3]
        layer4 = self.autoencoder.layers[-2]
        layer5 = self.autoencoder.layers[-1]
        
        encoded_layers = layer5(layer4(layer3(layer2(layer1(hidden_input)))))
        
        # Decoder model
        self.decoder = Model(hidden_input, encoded_layers)

        # Informations about models (autoencoder, encoder e decoder) 
        self.autoencoder.summary()
        self.encoder.summary()
        self.decoder.summary()

        # Compiler autoencoder using optimizer function adam
        self.autoencoder.compile(optimizer='adam', loss=rmse)

    # Methods
    # Method train autoencoder
    def train(self, input_train, input_test, batch_size, epochs):    
        self.autoencoder.fit(input_train, input_train,
                            epochs=epochs,
                            batch_size=batch_size,
                            shuffle=True,
                            validation_data=(input_train, input_test))
    
    # Method to return an encoded image
    def get_encoded_image(self, image):
        encoded_img = self.encoder.predict(image)
        return encoded_img
    
    # Method to return a decoded image
    def get_decoded_image(self, encoded_img):
        decoded_img = self.decoder.predict(encoded_img)
        return decoded_img

    # History informations about train
    def get_history_model(self):
        autoencoder_history = self.autoencoder.history
        return autoencoder_history

    # Get evaluate informations about train and test
    def get_evaluate_model(self, train, test):
        autoencoder_evaluate = self.autoencoder.evaluate(train, test)
        return autoencoder_evaluate

    # Method to save the models
    def save_model(self, name):
        name = name[:-4]
        self.autoencoder.save(models_h5 + 'autoencoder_' + name + '.h5')
        self.encoder.save(models_h5 + 'encoder_' + name + '.h5')
        self.decoder.save(models_h5 + 'decoder_' + name + '.h5')

"""Class main()"""

def main():
    images = []

    for img in os.listdir(data_png):
        try:
            # Normalization of training image and test image   
            img_train = mpimg.imread((os.path.join(data_png, img)))
            train = img_train.reshape((len(img_train), np.prod(img_train.shape[1:])))
            
            img_test = mpimg.imread((os.path.join(data_png, img)))
            test = img_train.reshape((len(img_train), np.prod(img_train.shape[1:])))

            print("Image: ", img)
            print("Initial Dimension: ", img_train.ndim)
            print("Initial Shape:", img_train.shape)
            print("Initial Size: ", img_train.size)

            print("Normalized Dimension: ", train.ndim)
            print("Normalized shape:", train.shape)
            print("Normalized Size: ", train.size)

            # Instantiation of class DeepAutoencoder
            deep_autoencoder = DeepAutoencoder(train.shape[1], 64)
            deep_autoencoder.train(train, test, 64, 10)
            
            # Start time
            start_time = time.time()
            
            # Get encoded and decoded image
            encoded_img = deep_autoencoder.get_encoded_image(test)
            decoded_img = deep_autoencoder.get_decoded_image(encoded_img)
            
            # End time
            end_time = time.time()

            # Total time
            times = (end_time - start_time) * 1000

            # Get history and evaluate about training
            deep_autoencoder_history = deep_autoencoder.get_history_model()
            deep_autoencoder_evaluate = deep_autoencoder.get_evaluate_model(train, test)
            
            # Save models (autoencoder, encoder and decoder)
            deep_autoencoder.save_model(img)
            
            # Plot images and graphics
            # Dimensions of original image
            image_shape = img_train.shape
            original_img_size = image_shape[0], image_shape[1], image_shape[2]

            # Resize original and decoded image
            original_result = test.reshape(original_img_size)
            decoded_img_result = decoded_img.reshape(original_img_size)

            decoded_reshape = decoded_img_result.reshape((len(decoded_img_result), 
                                                          np.prod(decoded_img_result.shape[1:])))    

            # Generate a plot with input, hidden layer and output
            images.append(original_result)
            images.append(encoded_img)
            images.append(decoded_img_result)

            # Generate a plot of metrics
            plot_metrics_history(deep_autoencoder_history, 'deep_autoencoder' + img)

            shape_0 = train.shape[0]

            # Calculate the compression to hidden layers (512, 384, 256, 128, 64)
            compression_original = ((shape_0 * train.shape[1]) / (shape_0 * train.shape[1])) * 100
            compression_512 = ((shape_0 * 512) / (shape_0 * train.shape[1])) * 100
            compression_384 = ((shape_0 * 384) / (shape_0 * train.shape[1])) * 100
            compression_256 = ((shape_0 * 256) / (shape_0 * train.shape[1])) * 100
            compression_128 = ((shape_0 * 128) / (shape_0 * train.shape[1])) * 100
            compression_64 = ((shape_0 * 64) / (shape_0 * train.shape[1])) * 100

            size_original = (shape_0 * train.shape[1])
            size_512 = (shape_0 * 512)
            size_384 = (shape_0 * 384)
            size_256 = (shape_0 * 256)
            size_128 = (shape_0 * 128)
            size_64 = (shape_0 * 64)

            # Calculate compression ratio
            print("Image: ", img)
            print("Encoded Dimension: ", encoded_img.ndim)
            print("Initial Shape Encoded:", encoded_img.shape)
            print("Encoded Size: ", encoded_img.size)
            
            print('Run time takes %d seconds' % times)
            print('Loss: %.2f%%' % ( deep_autoencoder_evaluate * 100 ))

            # Get the percentages of compression
            print('Original Pixels: %.2f%%\n' %  compression_original)
            print('512 Pixels: %.2f%%\n' %  compression_512)
            print('384 Pixels: %.2f%%\n' % compression_384)
            print('256 Pixels: %.2f%%\n' % compression_256)
            print('128 Pixels: %.2f%%\n' % compression_128)
            print('64 Pixels: %.2f%%\n' % compression_64)

            # Get sizes
            print('Original Pixels: %.2d\n' %  size_original)
            print('512 Pixels: %.2d\n' %  size_512)
            print('384 Pixels: %.2d\n' % size_384)
            print('256 Pixels: %.2d\n' % size_256)
            print('128 Pixels: %.2d\n' % size_128)
            print('64 Pixels: %.2d\n' % size_64)

            # Save images
            save_image('original_' + img, original_result)
            save_image('encoded_' + img, encoded_img)
            save_image('decoded_' + img, decoded_img_result)
            
        except Exception as e:
            print(e)
            pass

    plot_all(images)
    return

main()

"""Generate plot models"""

def rmse(y_true, y_pred):
	return backend.sqrt(backend.mean(backend.square(y_pred - y_true), axis=-1))

model_autoencoder_save = load_model('./models_h5/autoencoder_GOESR_RET_CH13_BMARBLE_20191009_1400.h5', custom_objects={'rmse':                   
rmse})
model_decoder_save = load_model('./models_h5/decoder_GOESR_RET_CH13_BMARBLE_20191009_1400.h5', custom_objects={'rmse':                   
rmse})
model_encoder_save = load_model('./models_h5/encoder_GOESR_RET_CH13_BMARBLE_20191009_1400.h5', custom_objects={'rmse':                   
rmse})

model_autoencoder_save.compile(optimizer='adam', loss=[rmse])
model_decoder_save.compile(optimizer='adam', loss=[rmse])
model_encoder_save.compile(optimizer='adam', loss=[rmse])

plot_model(model_autoencoder_save, to_file='autoencoder.png', show_shapes=True, show_layer_names=True, expand_nested=True)
plot_model(model_decoder_save, to_file='decoder.png', show_shapes=True, show_layer_names=True, expand_nested=True)
plot_model(model_encoder_save, to_file='encoder.png', show_shapes=True, show_layer_names=True, expand_nested=True)

"""Histograms"""

# Histograms
# Original
original_name = 'GOESR_RET_CH13_BMARBLE_20191009_1400'
original = mpimg.imread('./data_png/' + original_name + '.png', 0)  
simple_histogram('original_gray_' + original_name +'.png', original)
color_histogram('original_color_' + original_name + '.png', original)

# Histograms
# Decoded
decoded_name = 'decoded_GOESR_RET_CH13_BMARBLE_20191009_1400'
decoded = mpimg.imread('./results_png/' + decoded_name + '.png', 0)  
simple_histogram('decoded_gray_' + decoded_name +'.png', decoded)
color_histogram('decoded_color_' + decoded_name + '.png', decoded)

"""Get a cropped size of original image and decoded image to compare"""

from matplotlib.patches import Rectangle

# Load images
original = mpimg.imread("./data_png/GOESR_RET_CH13_IRCOL0_20191009_1400.png")
decoded = mpimg.imread("./results_png/decoded_GOESR_RET_CH13_IRCOL0_20191009_1400.png")

# Cropped original and decoded images
cropped_original = original[2000:3000, 2000:3000]
cropped_decoded = decoded[2000:3000, 2000:3000]

# Show original and decoded 
fig = plt.figure(figsize=(56, 56))
plt.title("Original Image")
plt.imshow(original)

# Show original and decoded 
fig = plt.figure(figsize=(56, 56))
plt.title("Decoded Image")
plt.imshow(decoded)

# Show original and decoded - Grid
fig = plt.figure(figsize=(56, 56))
plt.title("Original Image")
plt.grid(color='black', axis='both', linestyle='-', linewidth=5)
plt.gca().add_patch(Rectangle((2000,2000),1000,1000,linewidth=10,edgecolor='red',facecolor='none'))
plt.imshow(original)

fig = plt.figure(figsize=(56, 56))
plt.title("Decoded Image")
plt.grid(color='black', axis='both', linestyle='-', linewidth=5)
plt.gca().add_patch(Rectangle((2000,2000),1000,1000,linewidth=10,edgecolor='red',facecolor='none'))
plt.imshow(decoded)

# Show original and decoded croppeds
fig = plt.figure(figsize=(56, 56))
plt.title("Cropped original image {x1: 2000, y1: 2000, x2: 2000, y2: 3000}")
plt.imshow(cropped_original)

fig = plt.figure(figsize=(56, 56))
plt.title("Cropped decoded image {x1: 2000, y1: 2000, x2: 2000, y2: 3000}")
plt.imshow(cropped_decoded)

# Show original and decoded croppeds - Grid
fig = plt.figure(figsize=(56, 56))
plt.title("Cropped original image {x1: 2000, y1: 2000, x2: 2000, y2: 3000}")
plt.grid(color='black', linestyle='-', linewidth=5)
plt.gca().add_patch(Rectangle((200,200),200,200,linewidth=10,edgecolor='red',facecolor='none'))
plt.imshow(cropped_original)

fig = plt.figure(figsize=(56, 56))
plt.title("Cropped decoded image {x1: 2000, y1: 2000, x2: 2000, y2: 3000}")
plt.gca().add_patch(Rectangle((200,200),200,200,linewidth=10,edgecolor='red',facecolor='none'))
plt.grid(color='black', linestyle='-', linewidth=5)
plt.imshow(cropped_decoded)


# Cropped of cropped
cropped_original_1 = cropped_original[200:500, 200:500]
cropped_decoded_1 = cropped_decoded[200:500, 200:500]

# Show original and decoded 
fig = plt.figure(figsize=(56, 56))
plt.title("Original Image")
plt.imshow(cropped_original_1)

# Show original and decoded 
fig = plt.figure(figsize=(56, 56))
plt.title("Decoded Image")
plt.imshow(cropped_decoded_1)

# Show original and decoded - Grid
fig = plt.figure(figsize=(56, 56))
plt.title("Original Image")
plt.grid(color='black', axis='both', linestyle='-', linewidth=5)
plt.imshow(cropped_original_1)

fig = plt.figure(figsize=(56, 56))
plt.title("Decoded Image")
plt.grid(color='black', axis='both', linestyle='-', linewidth=5)
plt.imshow(cropped_decoded_1)

"""Load model and tests"""

from tensorflow.keras.models import load_model

def rmse(y_true, y_pred):
	return backend.sqrt(backend.mean(backend.square(y_pred - y_true), axis=-1))
 
# Load models using .npy

# model_decoder_save = load_model('./models_h5/decoder_GOESR_RET_CH09_WVCOL2_20191009_1320.h5')
# #model_decoder_save.compile(loss='mean_squared_error', optimizer='adam', metrics=[rmse])

# img_encoded = np.load('./data_npy/GOESR_RET_CH09_WVCOL2_20191009_1320.npy')
# img_decoded = model_decoder_save.predict(img_encoded)

# with open("./shapes_sizes_json/original_GOESR_RET_CH09_WVCOL2_20191009_1320.json", "r") as read_file:
#     data = json.load(read_file)

# test_encoder_result = img_decoded.reshape(data['rows'], data['columns'], data['channels'])
# plt.imshow(test_encoder_result)

# Load models using images

model_autoencoder_save = load_model('./models_h5/decoder_GOESR_RET_CH09_WVCOL2_20191009_1320.h5')
# model_encoder_save = load_model('./models/model_encoder__3_7880292.h5')

model_autoencoder_save.compile(optimizer='adam',  loss='mean_squared_error', metrics=['mse'])

img_test = mpimg.imread('./data_png/GOESR_RET_CH13_BMARBLE_20191009_1410.png')
max_test_value = float(img_test.max())
test_autoencoder = img_test.astype('float32') / max_test_value
test_autoencoder = test_autoencoder.reshape((len(test_autoencoder), np.prod(test_autoencoder.shape[1:])))

model_autoencoder_save.fit(test_autoencoder, test_autoencoder,
                        epochs=100,
                        batch_size=64,
                        shuffle=True,
                        validation_data=(test_autoencoder, test_autoencoder))

test = model_autoencoder_save.predict(test_autoencoder)
model_autoencoder_save.save('./test.h5')

to_reshape = img_test.shape

# test_encoder = model_encoder_save.predict(test_autoencoder)
# test_autoencoder = model_autoencoder_save.predict(test_autoencoder)

test_autoencoder_result = test.reshape(to_reshape[0], to_reshape[1], to_reshape[2])     
plt.imshow(test_autoencoder_result)

img_test = mpimg.imread('./data_png/GOESR_RET_CH09_WVCOL2_20191009_1310.png')
max_test_value = float(img_test.max())
test_autoencoder = img_test.astype('float32') / max_test_value
test_autoencoder = test_autoencoder.reshape((len(test_autoencoder), np.prod(test_autoencoder.shape[1:])))

autoencoder = DeepAutoencoder(test_autoencoder.shape[1], 64)
autoencoder.train(test_autoencoder, test_autoencoder, 64, 100)

encoded_img = autoencoder.get_encoded_image(test_autoencoder)
decoded_img = autoencoder.get_decoded_image(encoded_img)

"""Test model"""

model_decoder_save = load_model('./models_h5/decoder_GOESR_RET_CH13_BMARBLE_20191009_1400.h5')
#model_decoder_save.compile(loss='mean_squared_error', optimizer='adam', metrics=[rmse])

img_encoded = np.load('./data_npy/GOESR_RET_CH13_BMARBLE_20191009_1400.npy')
img_decoded = model_decoder_save.predict(img_encoded)

with open("./shapes_sizes_json/original_GOESR_RET_CH13_BMARBLE_20191009_1400.json", "r") as read_file:
    data = json.load(read_file)

test_encoder_result = img_decoded.reshape(data['rows'], data['columns'], data['channels'])
plt.imshow(test_encoder_result)


model_decoder_save = load_model('./models_h5/decoder_GOESR_RET_CH09_WVCOL2_20191009_1320.h5')
model_decoder_save.compile(loss='mean_squared_error', optimizer='adam', metrics=[rmse])

img_test = mpimg.imread('./data_png/GOESR_RET_CH09_WVCOL2_20191009_1310.png')
max_test_value = float(img_test.max())
test_autoencoder = img_test.astype('float32') / max_test_value
test_autoencoder = test_autoencoder.reshape((len(test_autoencoder), np.prod(test_autoencoder.shape[1:])))

model_decoder_save = load_model('./models_h5/autoencoder_GOESR_RET_CH09_WVCOL2_20191009_1310.h5')
test = model_decoder_save.predict(test_autoencoder)

to_reshape = img_test.shape

# test_encoder = model_encoder_save.predict(test_autoencoder)
# test_autoencoder = model_autoencoder_save.predict(test_autoencoder)

test_autoencoder_result = test.reshape(to_reshape[0], to_reshape[1], to_reshape[2])     
plt.imshow(test_autoencoder_result)